### Ошибка 1 — ошибка границы цикла (off-by-one)

Место: simulation.py, метод run, строка 208

Симптом:
Симуляция выполняет на 1 шаг больше, чем указано в параметре steps.
При запуске с steps=20 выполняется 21 шаг.

Как воспроизвести:
Запустить симуляцию с параметром steps=5:
run_simulation(steps=5, seed=42)
В выводе будет показано "всего 6 шагов" вместо 5.

Отладка:
Установлен breakpoint на строку for _ in range(steps + 1).
В отладчике видно значение steps = 5.
Выражение range(steps + 1) вычисляется как range(6).
Пошаговое выполнение показывает 6 итераций цикла.

Причина:
Использовано range(steps + 1) вместо range(steps).
range(n) генерирует числа от 0 до n-1, поэтому range(steps + 1) дает на одну итерацию больше.

Исправление:
Заменено на:
for _ in range(steps):
    self.run_step()

Проверка:
При запуске с steps=5 выполняется ровно 5 шагов.
В итоговой статистике показано "всего 5 шагов".

Доказательства:
- bug1_breakpoint.png
- bug1_variables.png
- bug1_callstack.png
- bug1_output.png

===============================================================================

### Ошибка 2 — неверное логическое условие

Место: Сollection.py, метод add_book, строка 89

Симптом:
Книги с пустым ISBN не добавляются в индекс, даже если это первая книга с таким ISBN.
Выводится сообщение "Книга с ISBN  уже существует в индексе".

Как воспроизвести:
Создать книгу с пустым ISBN и попытаться добавить:
book = Book("Тест", "Автор", 2024, "Жанр", "")
library.add_book(book)
Книга не добавится, результат будет False.

Отладка:
Установлен breakpoint на условие if book.isbn in self._isbn_index or book.isbn == "".
В отладчике видно:
book.isbn = ""
book.isbn in self._isbn_index = False
book.isbn == "" = True
Полное выражение: False or True = True
Условие срабатывает и книга отклоняется.

Причина:
Использовано неверное логическое условие с лишним ( or book.isbn == "" ).
Вторая часть условия всегда True для пустых ISBN.

Исправление:
Заменено на:
if book.isbn in self._isbn_index:
    print(f"Книга с ISBN {book.isbn} уже существует в индексе")
    return False

Проверка:
Книги с корректными ISBN добавляются нормально.
Дубликаты ISBN правильно отклоняются.

Доказательства:
- bug2_breakpoint.png
- bug2_condition.png
- bug2_variables.png

===============================================================================

### Ошибка 3 — изменение пользовательской коллекции во время итерации

Место: library.py, метод remove_books_by_genre, строки 53-60

Симптом:
При попытке удалить несколько книг одного жанра возникает исключение:
RuntimeError: dictionary changed size during iteration

Как воспроизвести:
Добавить несколько книг одного жанра:
library.add_book(Book("Книга1", "Автор1", 2020, "Роман", "ISBN-1"))
library.add_book(Book("Книга2", "Автор2", 2021, "Роман", "ISBN-2"))
library.add_book(Book("Книга3", "Автор3", 2022, "Роман", "ISBN-3"))
Вызвать метод:
library.remove_books_by_genre("Роман")
Программа выбросит RuntimeError.

Отладка:
Установлен breakpoint на строку for book in self._books.
На первой итерации вызывается self.remove_book(book).
Это изменяет коллекцию self._books.
При попытке продолжить итерацию возникает RuntimeError.
В стеке вызовов видна последовательность:
remove_books_by_genre → for book in self._books → self.remove_book → RuntimeError

Причина:
Нельзя изменять коллекцию во время итерации по ней.
Python отслеживает изменения коллекции и генерирует исключение при обнаружении модификации.

Исправление:
Заменено на:
books_to_remove = [book for book in self._books if book.genre == genre]
for book in books_to_remove:
    self.remove_book(book)
    removed_count += 1

Проверка:
Метод успешно удаляет все книги указанного жанра без ошибок.

Доказательства:
- bug3_exception.png
- bug3_breakpoint.png
- bug3_callstack.png
- bug3_variables.png

===============================================================================

### Ошибка 4 — использование изменяемого значения по умолчанию

Место: book.py, класс LibraryBook, метод __init__, строка 32

Симптом:
Все книги, созданные без параметра tags, используют один и тот же список.
Изменение тегов в одной книге влияет на все остальные книги.

Как воспроизвести:
Создать две книги без параметра tags:
book1 = LibraryBook("Книга1", "Автор1", 2020, "Роман", "ISBN-1", "INV-1", "A1")
book2 = LibraryBook("Книга2", "Автор2", 2021, "Роман", "ISBN-2", "INV-2", "A2")
Добавить тег в book1:
book1.tags.append("классика")
Проверить book2:
print(book2.tags)
Результат: ['классика'] вместо [].

Отладка:
Установлен breakpoint после создания обеих книг.
В отладчике проверены идентификаторы:
id(book1.tags) = 140234567890
id(book2.tags) = 140234567890
Одинаковые id означают один и тот же объект в памяти.
После добавления элемента в book1.tags изменяется и book2.tags.

Причина:
Изменяемые объекты в значениях по умолчанию создаются один раз при определении функции.
Параметр tags: List[str] = [] создает один список, который используется всеми экземплярами.

Исправление:
Заменено на:
def __init__(self, title: str, author: str, year: int, genre: str, isbn: str,
             inventory_number: str, shelf_location: str, 
             tags: Optional[List[str]] = None):
    ...
    self.tags = tags if tags is not None else []

Проверка:
Каждая книга теперь имеет независимый список тегов.
Изменение тегов одной книги не влияет на другие.

Доказательства:
- bug4_breakpoint.png
- bug4_ids.png
- bug4_shared_list.png
- bug4_fixed.png

===============================================================================

### Ошибка 5 — сравнение через is вместо ==

Место: simulation.py, метод _event_search_random_author, строка 159

Симптом:
Условие if len(results) is 1 работает непредсказуемо.
Иногда срабатывает при len(results) == 1, иногда нет.

Как воспроизвести:
Добавить автора с одной книгой:
library.add_book(Book("Книга", "Уникальный Автор", 2024, "Роман", "ISBN-1"))
Найти книги автора:
results = library.search_by_author("Уникальный Автор")
Проверить условие:
print(len(results) == 1)  # True
print(len(results) is 1)  # False
Условие с is не срабатывает, хотя длина равна 1.

Отладка:
Установлен breakpoint на условие if len(results) is 1.
В отладчике видно:
len(results) = 1
len(results) == 1 = True
len(results) is 1 = False
Проверка идентификаторов:
id(len(results)) = 140234567000
id(1) = 94234567890
Разные id означают разные объекты в памяти.

Причина:
Оператор is проверяет идентичность объектов, а не равенство значений.
Python кеширует только маленькие числа от -5 до 256.
Для динамически вычисленных значений создаются новые объекты.

Исправление:
Заменено на:
if len(results) == 1:
    self._log_event(f"Найдена единственная книга автора '{author}'")
else:
    self._log_event(f"Поиск по автору '{author}': найдено {len(results)} книг")

Проверка:
Условие теперь всегда корректно срабатывает при len(results) == 1.

Доказательства:
- bug5_breakpoint.png
- bug5_comparison.png
- bug5_ids.png
- bug5_evaluate.png

===============================================================================
